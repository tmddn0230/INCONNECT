ë©”íƒ€ë²„ìŠ¤ ê²½ì—°ëŒ€íšŒë¥¼ ìœ„í•´ â€˜VR ê°€ìƒ ë°ì´íŒ… ì»¨í…ì¸ â€™ë¥¼ ì œì¶œí•˜ê¸° ìœ„í•œ ì‚¬ì´ë“œ í”„ë¡œì íŠ¸ì…ë‹ˆë‹¤.

ğŸ‘¨â€ğŸ¦± ì°¸ì—¬ì¸ì› ë° ì—­í• 
- ê¹€ìœ¨í˜¸ : ê¸°íš
- ìœ ìŠ¹ìš° : TCP ì„œë²„ ë° ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
- ì •ê²½ì–¸ : ì»¨í…ì¸ 
- ìœ¤ì°¬ì˜ : ì›¹ ì„œë²„ ë° ìŒì„± ì±„íŒ…
- ê¹€ì¤€í˜ : UI
&nbsp;

&nbsp;
# <u>ğŸ“° ê¸°íš <u>
<details>
<summary> ğŸ’ë‘ê·¼ë‘ê·¼ ë²„ì¸„ì–¼ ëœë¤ ë§¤ì¹­ ë°ì´íŒ…ğŸ’ - ê¹€ìœ¨í˜¸ </summary>

[êµ¬í˜„ ëª©ë¡] 
1. ì•„ë°”íƒ€(ìœ ë‹ˆí‹° ì—ì…‹ ìŠ¤í† ì–´ì— ìˆëŠ” ë¬´ë£Œ ìºë¦­í„° 1ì¢…)
2. ê´‘ì¥(ìœ ë‹ˆí‹° ì—ì…‹ ìŠ¤í† ì–´ì— ìˆëŠ” ë¬´ë£Œ ë§µ 1ì¢… = ìºë¦­í„°ê°€ ìµœì´ˆ ìŠ¤í° ë˜ê³ , ì´ë™í•˜ë©´ì„œ ìŒì„±ëŒ€í™” í•  ìˆ˜ ìˆëŠ” ì •ë„ì˜ ê³µê°„)
3. UI(ëœë¤ ë§¤ì¹­ ë° ì´ëª¨í‹°ì½˜ ë“±ë“± 2D UI)
4. ëœë¤ ë°ì´íŠ¸ ì¥ì†Œ : ì¹´í˜(ì˜ì2ê°œì™€ íƒì1ê°œë¡œ ì´ë£¨ì–´ì§„ ê³µê°„) - í”„ë¡œí†  íƒ€ì… ë‹¨ê³„ì—ì„œëŠ” ì¹´í˜ë³´ë‹¤ëŠ” 1ëŒ€1 ì†Œí†µí•  ìˆ˜ ìˆëŠ” ì¥ì†Œ 
- ì¹´í˜ì—ì„œëŠ” ìµœì†Œí•œì˜ ì •ë³´ì™€ í–‰ë™ í•  ìˆ˜ ìˆëŠ” ê¶Œí•œ ì œê³µ(ì¶”í›„ ê°œë°œ ì˜ˆì •)
- ì •í•´ì§„ ì„ë¬´ì— ë”°ë¼ ì‚¬ìš©ìì˜ ì •ë³´ì™€ í–‰ë™ì˜ ë²”ìœ„ê°€ í•´ê¸ˆë˜ì–´ ë”ìš± ììœ ë¡­ê²Œ ìƒëŒ€ë¥¼ ì•Œì•„ ê°ˆ ìˆ˜ ìˆëŠ” íš¨ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.(ì¶”í›„ ê°œë°œ ì˜ˆì •)
â‡’ ì •í•´ì§„ í–‰ë™ : ìƒëŒ€ë°©ì˜ ìš”êµ¬ì‚¬í•­,ì¶¤ or ë…¸ë˜
â‡’ í•´ê¸ˆ : ë³´ì´ìŠ¤ ì±„íŒ…, MBTI, ì‚¬ìš©ì ì´ë¦„, ì¸ìŠ¤íƒ€ ì•„ì´ë”” ë“±ë“±

[ê³ ë ¤ í•´ì•¼ í•  ì‚¬í•­]

1. ìºë¦­í„°ìƒ ì„±ë³„
2. ëª¨ì…˜ìº¡ì³ë¥¼ ì´ìš©í•œ ì´ëª¨í‹°ì½˜ 

 3.  ëª¨ì…˜ìº¡ì³ëŠ” ì†ëª©ê¹Œì§€ ì‚¬ìš© , ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ì¡ê³  ì§„í–‰í•˜ë©° ì»¨íŠ¸ë¡¤ëŸ¬ ëŒ€ì‹  ì†ëª¨ì–‘ì„ ëœë”ë§

 4. ë°°ê·¸ ê°ì •í‘œí˜„ ì²˜ëŸ¼ RADIAL UI ì—ì„œ ì„ íƒí•˜ë©´ í•´ë‹¹ ì œìŠ¤ì³ë¥¼ ì·¨í•˜ê±°ë‚˜

1. ê·¸ ë°˜ëŒ€ë¡œ ì œìŠ¤ì³ë¥¼ ì·¨í•˜ë©´ ì´ëª¨í‹°ì½˜ì„ ìœ„ì— ì¶œë ¥
2. ê´‘ì¥ ë©€í‹° (20ì¸ ê¸‰)

â‡’  ê´‘ì¥ì—ì„œëŠ” 1, 3ì¸ì¹­ : ëª¨ì…˜ x , ì•„ë°”íƒ€ ì»¨íŠ¸ë¡¤ + ì±„íŒ… 

ë°ì´íŒ… ì‹œì‘í•  ë•Œë§Œ ëª¨ì…˜ + 1ì¸ì¹­

ì—…ì  ìºë¦­í„° ë¨¸ë¦¬ìœ„ì— í‘œê¸° (ex: ì¹´í˜ë°ì´íŠ¸ 50ëª… í•˜ê³ ì˜¨ì‚¬ëŒ, ì˜¤ë½ì‹¤10ìœ„ì•ˆì—ë“¤ì–´ì˜¨ì‚¬ëŒ)

ê°€ê¹Œì´ ê°€ì„œ ì»¨íŠ¸ë¡¤ëŸ¬ UI ìƒí˜¸ì‘ìš©?? â‡’ ë°ì´íŠ¸ ì‹ ì²­, ì¸ì‚¬í•˜ê¸° (ì´ëª¨í‹°ì½˜)

[Date_In_Persona_í”„ë¡œí† íƒ€ì…_ê¸°íšì„œ_V.1.0.pptx](https://github.com/user-attachments/files/17892260/Date_In_Persona_._._V.1.0.pptx)<br>
[Date In Persona_ì¹´í˜ì‹œìŠ¤í…œ_ê¸°íšì„œ_V.1.0.pptx](https://github.com/user-attachments/files/17892262/Date.In.Persona_._._V.1.0.pptx)<br>
[Date In Persona_UIì»¨ì…‰ê¸°íšì„œ_V.1.0.pdf](https://github.com/user-attachments/files/17892263/Date.In.Persona_UI._V.1.0.pdf)<br>
[Dating_ì‹œìŠ¤í…œê¸°íšì„œ_v01.pptx](https://github.com/user-attachments/files/17892264/Dating_._v01.pptx)<br>
</details>


&nbsp;

&nbsp;
# <u>ğŸ’» ì£¼ìš” ê¸°ëŠ¥ ë° ì½”ë“œ<u>

[Server]  : C++
<details>
 <summary> ICPacket : Used Packets - ìœ ìŠ¹ìš°</summary>

## &nbsp;&nbsp;&nbsp;&nbsp;ì‚¬ìš© íŒ¨í‚·ê³¼ íŒ¨í‚·ê´€ë¦¬ í
    
```cpp

namespace Packet
{
    public enum enProtocol
    {
        PROTOCOL_START = 0,
        prConnectAck,
        prLoginReq, prLoginAck,
        prBoneData,
        prTransform,
        prMatchingReq, prMatchingAck,
        prFirstAttract,
        prMBTI,
        prSendEmo,
        prAfter,

        PROTOCOL_END
    };

    [StructLayout(LayoutKind.Sequential, Pack = 1)]   // Pack ì€ ë©¤ë²„ê°„ ì •ë ¬ê°„ê²©ì´ 1ë°”ì´íŠ¸  ë©¤ë²„ê°€ ê°ê° 1 ë°”ì´íŠ¸, 4ë°”ì´íŠ¸ ë¼ë©´ êµ¬ì¡°ì²´ì˜ í¬ê¸°ëŠ” 5ë°”ì´íŠ¸ë€ ì–˜ê¸°
                                                      // ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ 8ë°”ì´íŠ¸
    [System.Serializable]
    public struct StHeader
    {
        public ushort nID;
        public ushort nSize;
        public ushort nType;
        public ushort nCheckSum;

        public void SetHeader(int id, int len)
        {
            nType = 2222;
            nID = (ushort)id;
            nSize = (ushort)len;
            nCheckSum = (ushort)(nType + nID + nSize);
        }
    }


    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [System.Serializable]
    public struct ICPacket_Bone 
    {

        public StHeader packetHeader;
        public int UID;
        public CoreBoneData bonedata;

        public void SetMotionProtocol()
        {
            int size;
            size = Marshal.SizeOf(packetHeader) + Marshal.SizeOf(bonedata) + sizeof(int);
            packetHeader = new StHeader();
            packetHeader.SetHeader((int)enProtocol.prBoneData, size);
        }     
        
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [System.Serializable]
    public struct ICPacket_Transform
    {

        public StHeader packetHeader;
        public int UID;
        float[] pos;
        float[] rot;

        public void Init()
        {
            pos = new float[3];
            rot = new float[4];
        }

        public void SetMotionProtocol()
        {
            int size;
            size = Marshal.SizeOf(packetHeader) + (sizeof(float) * pos.Length)  + (sizeof(float) * rot.Length);
            packetHeader = new StHeader();
            packetHeader.SetHeader((int)enProtocol.prTransform, size);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [System.Serializable]
    public class ICPacket_Login
    {
        public StHeader packetHeader;

        public int UID;
        public int Result;

        public void SetLoginProtocol()
        {
            int size;
            size = Marshal.SizeOf(packetHeader) + sizeof(int) + sizeof(int);
            packetHeader = new StHeader();
            packetHeader.SetHeader((int)enProtocol.prLoginReq, size);
        }
    }


    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [System.Serializable]
    public class ICPacket_Match
    {
        public StHeader packetHeader;
        public void SetMatchProtocol()
        {
            int size;
            size = Marshal.SizeOf(packetHeader) + sizeof(int) + sizeof(int); // ë©¤ë²„ì— ë”°ë¼ ìˆ˜ì •
            packetHeader = new StHeader();
            packetHeader.SetHeader((int)enProtocol.prMatchingReq, size);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [System.Serializable]
    public class ICPacket_First
    {
        public StHeader packetHeader;
        public int UID;
        public int Score;
        
        public void SetAttractProtocol()
        {
            int size;
            size = Marshal.SizeOf(packetHeader) + sizeof(int) + sizeof(int); // ë©¤ë²„ì— ë”°ë¼ ìˆ˜ì •
            packetHeader = new StHeader();
            packetHeader.SetHeader((int)enProtocol.prFirstAttract, size);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [System.Serializable]
    public class ICPacket_MBTI
    {
        public StHeader packetHeader;
        public int UID;
        public int MBTI; // mbti 1 ~ 12
        public void SetMBTIProtocol()
        {
            int size;
            size = Marshal.SizeOf(packetHeader) + sizeof(int) + sizeof(int); // ë©¤ë²„ì— ë”°ë¼ ìˆ˜ì •
            packetHeader = new StHeader();
            packetHeader.SetHeader((int)enProtocol.prMBTI, size);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [System.Serializable]
    public class ICPacket_EMO
    {
        public StHeader packetHeader;
        public int UID;
        public int EMO;
        public void SetEmoProtocol()
        {
            int size;
            size = Marshal.SizeOf(packetHeader) + sizeof(int) + sizeof(int); // ë©¤ë²„ì— ë”°ë¼ ìˆ˜ì •
            packetHeader = new StHeader();
            packetHeader.SetHeader((int)enProtocol.prSendEmo, size);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [System.Serializable]
    public class ICPacket_After
    {
        public StHeader packetHeader;
        public int UID;
        public int Result;
        public void SetAfterProtocol()
        {
            int size;
            size = Marshal.SizeOf(packetHeader) + sizeof(int) + sizeof(int); // ë©¤ë²„ì— ë”°ë¼ ìˆ˜ì •
            packetHeader = new StHeader();
            packetHeader.SetHeader((int)enProtocol.prAfter, size);
        }
    }

    public class ICPacketQueue
    {
        private Queue<byte[]> queue;
        
        public ICPacketQueue()
        {
            queue = new Queue<byte[]>();
        }

        public void Enqueue(byte[] packet)
        {
            queue.Enqueue (packet);
            Debug.Log("Enqueue !");
        }

        public byte[] Dequeue()
        {
            if (queue.Count > 0)
            {
                byte[] packet = queue.Dequeue();
                Debug.Log("Dequeue !");
                return packet;
            }
            else
            {
                Debug.Log("Queue is Empty");
                return null;
            }
        }

    }
}

```


</details>

<details>
<summary> ICServer : Main Socket Server - ìœ ìŠ¹ìš° </summary>

 ì„œë²„ íŠ¹ì§•<br>
  1. TCP Socket<br>
  2. Event Select<br>
## &nbsp;&nbsp;&nbsp;&nbsp;ì†Œì¼“ ì´ˆê¸°í™” ë° ì„œë²„ ì‹¤í–‰
    
```cpp
    // Start WinSock
    WinSockStart();

    // Create Event
    int i;
    for (i = 0; i < MAX_USER; ++i)
    {
        gEvent[i] = WSACreateEvent();
    }

    // Accept Thread
    gServerHandle = (HANDLE)_beginthreadex(NULL, 0, ServerThread, NULL, 0, NULL);

    // User Thread
    for (i = 0; i < MAX_THREAD; ++i)
    {
        gUserHandle[i] = NULL;
        gUserHandle[i] = (HANDLE)_beginthreadex(NULL, 0, UserThread, (void*)i, 0, NULL);
    }
```
## &nbsp;&nbsp;&nbsp;&nbsp;ì„œë²„ ì“°ë ˆë“œ
    
```cpp
unsigned __stdcall ServerThread(void* pArg)
{
    char szBuffer[1024];	memset(szBuffer, 0x00, sizeof(szBuffer));

    gServerSocket = socket(AF_INET, SOCK_STREAM, 0);

    if (gServerSocket == INVALID_SOCKET)
    {
        sprintf(szBuffer, "Socket error code=%x", WSAGetLastError());
        puts(szBuffer);
        return 0;
    }

    //ë‚˜ê²”ì•Œê³ ë¦¬ì¦˜ ë¹„ì ìš©
    BOOL opt_val = TRUE;
    setsockopt(gServerSocket, IPPROTO_TCP, TCP_NODELAY, (char*)&opt_val, sizeof(opt_val));
    DWORD size = 0x8000;
    setsockopt(gServerSocket, SOL_SOCKET, SO_SNDBUF, (const char*)&size, sizeof(size));
    setsockopt(gServerSocket, SOL_SOCKET, SO_RCVBUF, (const char*)&size, sizeof(size));

    struct sockaddr_in sa;
    memset(&sa, 0, sizeof(sa));
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = htonl(INADDR_ANY);
    sa.sin_port = htons(gServerPort);

    //Bind
    if (::bind(gServerSocket, (struct sockaddr*)&sa, sizeof(sa)) != 0)
    {
        sprintf(szBuffer, "bind error code=%d", WSAGetLastError());
        puts(szBuffer);
        return 0;
    }

    //Listen
    if (listen(gServerSocket, 500) != 0)
    {
        sprintf(szBuffer, "listen error code=%d", WSAGetLastError());
        puts(szBuffer);
        return 0;
    }

    while (gServerHandle)
    {
        struct sockaddr_in ca;
        int clientAddressLength = sizeof(ca);
        int nLength = sizeof(ca);

        SOCKET socket = accept(gServerSocket, (struct sockaddr*)&ca, &nLength);

        if (socket == INVALID_SOCKET)
        {
            closesocket(socket);

            puts("Failed Socket Create");
            continue;
        }
        //ìœ ì €ë“±ë¡ì— ì‹¤íŒ¨í•˜ë©´ ì†Œì¼“ì„ ë‹«ì•„ë²„ë¦°ë‹¤..

       if (g_User.AddUser(socket, ca) == false)
       {
           closesocket(socket);
       
           printf("ADDUser Fail %d.%d.%d.%d",
               ca.sin_addr.S_un.S_un_b.s_b1,
               ca.sin_addr.S_un.S_un_b.s_b2,
               ca.sin_addr.S_un.S_un_b.s_b3,
               ca.sin_addr.S_un.S_un_b.s_b4);
       }

        Sleep(1);
    }
    return 0;

}
```

## &nbsp;&nbsp;&nbsp;&nbsp;ìœ ì € ì“°ë ˆë“œ
    
```cpp
unsigned __stdcall UserThread(void* pArg)
{
    WSANETWORKEVENTS events;

    DWORD dwReturn = 0, dwRet = 0;

    //int nread;
    int ThreadArray = (int)pArg;
    int UserArray = (ThreadArray * gUserper);
    int i = 0;
    int inum = 0;
    //Log("UserThread %d", ThreadArray );
    while (gUserHandle[ThreadArray])
    {
        //64ê°œ..
        dwReturn = WSAWaitForMultipleEvents(gUserper, &gEvent[UserArray], FALSE, WSA_INFINITE, FALSE);

        if (dwReturn != WSA_WAIT_FAILED)
        {
            for (i = 0; i < gUserper; ++i)
            {
                inum = UserArray + i;

                // UserManager
                if (g_User.mUser[inum].mhSocket)
                {
                
                    dwRet = WSAEnumNetworkEvents(g_User.mUser[inum].mhSocket, gEvent[inum], &events);
                
                    if (dwRet == 0)
                    {
                        //FD_READ EVENT ë©´.
                        if ((events.lNetworkEvents & FD_READ) == FD_READ)
                        {
                            g_User.mUser[inum].Recv();
                        }
                        if ((events.lNetworkEvents & FD_WRITE) == FD_WRITE)
                        {
                            g_User.mUser[inum].FlushSendBuffer();
                        }
                        if ((events.lNetworkEvents & FD_CLOSE) == FD_CLOSE)
                        {
                            //ì ‘ì† ì¢…ë£Œ ì²˜ë¦¬
                            //Log("g_User.DelUser( inum %d );", inum );
                            g_User.DelUser(inum);
                        }
                    }
                }
            }
        }
        Sleep(1);
    }
    return 0;
}

```

## &nbsp;&nbsp;&nbsp;&nbsp;Send & Recv
    
```cpp
bool User::AddSendBuffer(char* buff, int size)
{
	if( buff == NULL)
	   return false;
	if (mSendSize + size >= MAX_SEND)
	{
		Clear();
		return false;
	}

	memcpy(&mSendBuffer[mSendSize], buff, size);
	mSendSize += size;
	return true;
}

void User::Send(char* buff, int size)
{
	if (mhSocket == NULL) {
		return;
	}
	if (buff == NULL)
		return;

	int sendsize, error = 0;
	if (mSendSize <= 0) {// Only once Case : Queue Empty

		do {
			sendsize = send(mhSocket, buff, size, 0);

			if (sendsize < 0) {
				AddSendBuffer(buff, size);
				break;
			}
			else
			{
					buff = buff + sendsize; // ë²„í¼ì˜ ìœ„ì¹˜ë¥¼ send í•œ ë§Œí¼ ë’¤ë¡œ ë°ˆ
					size -= sendsize;       // íŒ¨í‚· ì‚¬ì´ì¦ˆë¥¼ ë³´ë‚¸ë§Œí¼ ë¹¼ì¤€ë‹¤.
			}
		} while (size);                 // sizeê°€ 0ì´ ë  ë•Œê¹Œì§€ ë³´ë‚¸ë‹¤.

	}
	else {// íê°€ ë¹„ì–´ìˆì§€ ì•Šë‹¤ë©´ ë³´ë‚¼ ë°ì´í„°ë¥¼ íì— ìŒ“ê³ , 
			// ë²„í¼ë¥¼ ì´ˆê³¼í•˜ì§€ ì•Šì•˜ë‹¤ë©´ FlushBuffer();ë¥¼ í˜¸ì¶œí•´ì„œ ì²˜ë¦¬í•œë‹¤.
		if (AddSendBuffer(buff, size)) {
			FlushSendBuffer();
		}
		else {
			FlushSendBuffer();
		}
	}
}

void User::Recv()
{
	if (mhSocket == NULL)
		return;
	if (mIndex < 0)
		return;

	int size = 0;
	if (mRecvWrite < MAX_RECV)
		size = recv(mhSocket, &mRecvBuffer[mRecvWrite], MAX_RECV - mRecvWrite, 0);
	    //stTestPacket header;
	    //memcpy(&header, mRecvBuffer, sizeof(stTestPacket));

	if (size > 0) {
		// ADD at Current RecvBuffer's Length
		mRecvWrite += size;

		if (mRecvWrite >= MAX_RECV) {
			puts("User Buffer is Full");
		}

		while (mRecvWrite >= HEADSIZE) {
			stHeader header;
			memcpy(&header, mRecvBuffer, HEADSIZE);
			// Why didn't use ?
			//if (header.nID >= PROTOCOL_END || header.nID <= PROTOCOL_START) {
			//	Clear();
			//	EmptyRecvBuffer();
			//	return;
			//}


			if (header.nSize <= 0) {
				EmptyRecvBuffer();
				return;
			}
			int iCheckSum = header.nType + header.nSize + header.nID;
			if (header.nCheckSum != iCheckSum) {
				EmptyRecvBuffer();
				return;
			}

			if (mRecvWrite >= header.nSize) {
				Parse(header.nID, mRecvBuffer);
				memmove(mRecvBuffer, &mRecvBuffer[header.nSize], mRecvWrite);
				mRecvWrite -= header.nSize;
			}
			else {
				break;
			}
		}
	}
}

void UserManager::SendOther(int index, char* buff, int size)
{
	int i;
	for (i = 0; i < MAX_USER; ++i)
	{
		if (i == index)
			continue;

		mUser[i].Send(buff, size);
	}
}

void UserManager::SendAll(char* buff, int size)
{
	int i;
	for (i = 0; i < MAX_USER; ++i)
	{
		mUser[i].Send(buff, size);
	}
}
```
## &nbsp;&nbsp;&nbsp;&nbsp;ìœ ì € ê´€ë¦¬
    
```cpp
int UserManager::GetUserCount()
{
	int i;
	int nCount = 0;
	for (i = 0; i < MAX_USER; ++i)
	{
		if (mUser[i].mhSocket == NULL)
			continue;
		nCount++;
	}
	return nCount;
}

bool UserManager::AddUser(SOCKET sock, sockaddr_in ip)
{
	int i;
	for (i = 0; i < MAX_USER; ++i)
	{
		if (mUser[i].mhSocket != NULL)
			continue;

		WSAResetEvent(gEvent[i]);
		WSAEventSelect(sock, gEvent[i], FD_READ | FD_WRITE | FD_CLOSE);

		BOOL opt_val = TRUE;
		setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char*)&opt_val, sizeof(opt_val));

		DWORD recvsize = MAX_RECV;
		DWORD sendsize = MAX_SEND;
		setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (const char*)&recvsize, sizeof(recvsize));
		setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (const char*)&sendsize, sizeof(sendsize));

		struct linger Linger;
		Linger.l_onoff = 1; //ë§ê±° ë„ê¸°, Time Wait
		Linger.l_linger = 0;
		setsockopt(sock, SOL_SOCKET, SO_LINGER, (const char*)&Linger, sizeof(Linger));


		mUser[i].Init(i, sock, ip);

		printf("AddUser: %d %d.%d.%d.%d", i,
			ip.sin_addr.S_un.S_un_b.s_b1,
			ip.sin_addr.S_un.S_un_b.s_b2,
			ip.sin_addr.S_un.S_un_b.s_b3,
			ip.sin_addr.S_un.S_un_b.s_b4);

		return true;

	}
	return false;
}

void UserManager::DelUser(int index)
{
	if (index < 0 || index >= MAX_USER)
		return;

	mUser[index].LogOut();
}

User* UserManager::GetUser(int uid)
{
	if (uid <= 0)
		return NULL;

	int i;
	for (i = 0; i < MAX_USER; ++i)
	{
		if (mUser[i].mUID == uid)
			return &mUser[i];
	}
	return NULL;
}

```
</details>

<details>
<summary> ICVoiceServer : Voice Server </summary>

   1. UDP Socket
</details>

&nbsp;
&nbsp;

[Client] : C#
<details>
<summary> NetworkManager - ìœ ìŠ¹ìš° </summary>

 
### &nbsp;&nbsp;&nbsp;ICNetworkManager   
## &nbsp;&nbsp;&nbsp;&nbsp;ë³€ìˆ˜ ì„ ì–¸
    
```csharp

    // Login Info
    int UID;

    // Test InputField UI
    public InputField mIPInput, mPortInput, mNickInput;
    private ICPacketQueue SendPacketQueue;

    String mClientName;

    bool bSocketReady;
    TcpClient mSocket;
    NetworkStream mStream;
    StreamWriter mWriter;
    StreamReader mReader;

    // Thread 
    Thread sendThread;
    Thread recvThread;
    Queue<byte[]> sendQueue;
    Queue<byte[]> recvQueue;
    bool bRun = false;
    object queueLock = new object();

    // Receiver
    ICPacketReciever packetReciever;
    ICMotionReciever motionReciever;
```

## &nbsp;&nbsp;&nbsp;&nbsp; ì„œë²„ ì ‘ì†
```csharp
public void ConnectToServer()
{
    // if Client Connected aready, return
    if (bSocketReady) return;

    // HOST / PORT
    string ip = "58.127.66.152";
    int port = 25000;

    // Create Socket 
    try
    {
        mSocket = new TcpClient(ip, port);
        mStream = mSocket.GetStream();
        mWriter = new StreamWriter(mStream);
        mReader = new StreamReader(mStream);
        sendThread = new Thread(ProcessSendPackets);
        sendThread.Start();
        SendPacketQueue = new ICPacketQueue();

        bRun = true;
        bSocketReady = true;

        // Receiver
        motionReciever = new ICMotionReciever();
        motionReciever.Init();
    }
    catch(Exception e)
    {
        Debug.Log($"Error: Can't Create Client Socket {e}");
    }

}
```
## &nbsp;&nbsp;&nbsp;&nbsp; Queue ì— Send Packet ìŒ“ê¸°
```csharp  
    public void SendPacket_Bone(ICPacket_Bone packet)
    {
        int size = packet.packetHeader.nSize;
        byte[] bytes = new byte[size];
        IntPtr ptr = Marshal.AllocHGlobal(size);
        try
        {
            Marshal.StructureToPtr(packet, ptr, true);
            Marshal.Copy(ptr, bytes, 0, size);
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }

        SendPacketQueue.Enqueue(bytes);
    }
```
## &nbsp;&nbsp;&nbsp;&nbsp; Send Packet ì²˜ë¦¬ 
```csharp
    private void ProcessSendPackets()
    {
        Debug.Log("Processing thread started.");
        while (bRun)
        {

            if(SendPacketQueue == null) continue;
            byte[] dequeueBytes;
            dequeueBytes = SendPacketQueue.Dequeue();
            if (dequeueBytes != null)
            {
                // ì—¬ê¸°ì„œ Send
                Debug.Log("Packet");
                using (MemoryStream ms = new MemoryStream())
                {
                    BinaryWriter writer = new BinaryWriter(ms);
                    mStream.Write(dequeueBytes, 0, dequeueBytes.Length);
                }
            }
            else
            {
                Debug.Log("Packet Empty");
            }

         
            Thread.Sleep(10);
        }

    }

```

## &nbsp;&nbsp;&nbsp;&nbsp;Convert Structure
```csharp
    private T ByteArrayToStructure<T>(byte[] bytes) where T : struct
    {
        IntPtr ptr = Marshal.AllocHGlobal(bytes.Length);
        Marshal.Copy(bytes, 0, ptr, bytes.Length);
        T obj = (T)Marshal.PtrToStructure(ptr, typeof(T));
        Marshal.FreeHGlobal(ptr);
        return obj;
    }

```
## &nbsp;&nbsp;&nbsp;&nbsp; Recv 
```csharp
    private void ReceiveData()
    {
        try
        {
            // í—¤ë” í¬ê¸°ë¥¼ ì½ìŠµë‹ˆë‹¤
            int headerSize = Marshal.SizeOf(typeof(StHeader));
            byte[] headerBuffer = new byte[headerSize];
            int bytesRead = mStream.Read(headerBuffer, 0, headerSize);

            if (bytesRead != headerSize)
            {
                throw new Exception("Failed to read packet header");
            }

            // í—¤ë” ì •ë³´ë¥¼ ì½ì–´ íŒ¨í‚· í¬ê¸°ë¥¼ í™•ì¸í•©ë‹ˆë‹¤
            StHeader header = ByteArrayToStructure<StHeader>(headerBuffer);

            // í—¤ë”ì˜ í”„ë¡œí† ì½œì— ë”°ë¼ 
            Parse(header);
        }
        catch (Exception e)
        {
            Debug.Log("Receive Error: " + e.Message);
        }
    }
```
## &nbsp;&nbsp;&nbsp;&nbsp; Close Socket
```csharp
    void OnApplicationQuit()
    {
        CloseSocket();
    }

    void CloseSocket()
    {
        if (!bSocketReady) return;

        mWriter.Close();
        mReader.Close();
        mSocket.Close();
        bSocketReady = false;
    }
```
</details>

<details>
<summary> MotionSynchronizing - ìœ ìŠ¹ìš° </summary>

### &nbsp;&nbsp;&nbsp;ICNetworkManager   
## &nbsp;&nbsp;&nbsp;&nbsp;Parse by Packet
    
```csharp

    void Parse(StHeader header)
    {
        switch ((enProtocol)header.nID)
        {
            case enProtocol.prConnectAck:
                RecvConnectAck(header);
                break;
            case enProtocol.prBoneData:
                RecvBoneData(header);
                break;
            case enProtocol.prLoginAck:
                RecvLoginAck(header);
                break;
            case enProtocol.prMatchingAck:
                break;
            case enProtocol.prMBTI:
                RecvMBTI(header);
                break;
            case enProtocol.prAfter:
                RecvAfter(header);
                break;
            case enProtocol.prSendEmo:
                RecvEmotion(header);
                break;
            case enProtocol.prTransform:
                RecvTransformData(header);
                break;
            case enProtocol.prFirstAttract:
                RecvFisrtAttract(header);
                break;
        }
    }
```
## &nbsp;&nbsp;&nbsp;&nbsp;RecvBoneData
   
```csharp
float[] readfloat(float[] values, BinaryReader reader)
{
        values = new float[values.Length];

        for(int i = 0; i < values.Length; i++)
        {
            values[i] = reader.ReadSingle();
        }
        return values;
}

void RecvBoneData(StHeader header)
{
     int headerSize = Marshal.SizeOf(typeof(StHeader));
     int totalSize = header.nSize - headerSize;
     // ì „ì²´ íŒ¨í‚· ë°ì´í„°ë¥¼ ì½ìŠµë‹ˆë‹¤
     byte[] buffer = new byte[totalSize];
     int bytesRead = mStream.Read(buffer, 0, totalSize);

     if (bytesRead != totalSize)
     {
         throw new Exception("Failed to read packet data");
     }

     // ë°ì´í„°ë¥¼ MemoryStreamì— ì €ì¥í•˜ê³  ì½ì–´ ë“¤ì…ë‹ˆë‹¤
     using (MemoryStream ms = new MemoryStream(buffer))
     {
         BinaryReader reader = new BinaryReader(ms);

         // UID ì½ê¸°
         int UID = reader.ReadInt32();

         CoreBoneData bonepacket = new CoreBoneData();
         bonepacket.Init();

         bonepacket.headPosition = readfloat(bonepacket.headPosition, reader);
         bonepacket.headRotation = readfloat(bonepacket.headRotation, reader);
         bonepacket.neckPosition = readfloat(bonepacket.neckPosition, reader);
         bonepacket.neckRotation = readfloat(bonepacket.neckRotation, reader);
         bonepacket.chestPosition = readfloat(bonepacket.chestPosition, reader);
         bonepacket.chestRotation = readfloat(bonepacket.chestRotation, reader);
         bonepacket.spinePosition = readfloat(bonepacket.spinePosition, reader);
         bonepacket.spineRotation = readfloat(bonepacket.spineRotation, reader);
         bonepacket.hipPosition = readfloat(bonepacket.hipPosition, reader);
         bonepacket.hipRotation = readfloat(bonepacket.hipRotation, reader);
                    // Hands
         bonepacket.leftUpperArmPosition = readfloat(bonepacket.leftUpperArmPosition, reader);
         bonepacket.leftUpperArmRotation = readfloat(bonepacket.leftUpperArmRotation, reader);
         bonepacket.leftLowerArmPosition = readfloat(bonepacket.leftLowerArmPosition, reader);
         bonepacket.leftLowerArmRotation = readfloat(bonepacket.leftLowerArmRotation, reader);
         bonepacket.leftHandPosition = readfloat(bonepacket.leftHandPosition, reader);
         bonepacket.leftHandRotation = readfloat(bonepacket.leftHandRotation, reader);
         bonepacket.rightUpperArmPosition = readfloat(bonepacket.rightUpperArmPosition, reader);
         bonepacket.rightUpperArmRotation = readfloat(bonepacket.rightUpperArmRotation, reader);
         bonepacket.rightLowerArmPosition = readfloat(bonepacket.rightLowerArmPosition, reader);
         bonepacket.rightLowerArmRotation = readfloat(bonepacket.rightLowerArmRotation, reader);
         bonepacket.rightHandPosition = readfloat(bonepacket.rightHandPosition, reader);
         bonepacket.rightHandRotation = readfloat(bonepacket.rightHandRotation, reader);
                    // Foots
         bonepacket.leftFootPosition = readfloat(bonepacket.leftFootPosition, reader);
         bonepacket.leftFootRotation = readfloat(bonepacket.leftFootRotation, reader);
         bonepacket.rightFootPosition = readfloat(bonepacket.rightFootPosition, reader);
         bonepacket.rightFootRotation = readfloat(bonepacket.rightFootRotation, reader);

         motionReciever.AddDictionary(UID, bonepacket);
     }
}

```
</details>

&nbsp;

&nbsp;
# <u> ğŸ–Œï¸ UI ë° ë””ìì¸ - ê¹€ì¤€í˜ <u>


